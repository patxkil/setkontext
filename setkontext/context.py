"""Generate context files for AI coding agents.

Produces CLAUDE.md, .cursorrules, or generic context files from extracted
decisions. These files are loaded automatically by agents as system context,
giving them awareness of your team's architectural decisions.
"""

from __future__ import annotations

from pathlib import Path

from setkontext.storage.repository import Repository

CONTEXT_HEADER = """\
# Engineering Decisions Context

This file was auto-generated by setkontext from your team's GitHub history.
It captures architectural decisions, technology choices, and design patterns
so that AI coding agents have context about WHY this system is built the way it is.

**Do not suggest changes that contradict these decisions without explicitly flagging the conflict.**

"""

SECTION_SEPARATOR = "\n---\n\n"


def generate_context(repo: Repository, format: str = "claude") -> str:
    """Generate a context string from all extracted decisions.

    Args:
        repo: Repository with extracted decisions.
        format: 'claude' for CLAUDE.md, 'cursor' for .cursorrules, 'generic' for plain markdown.
    """
    decisions = repo.get_all_decisions(limit=200)
    entities = repo.get_entities()
    stats = repo.get_stats()

    if not decisions:
        return "# No engineering decisions extracted yet.\n\nRun `setkontext extract` first.\n"

    parts: list[str] = []

    # Header
    if format == "cursor":
        parts.append(_cursor_header())
    else:
        parts.append(CONTEXT_HEADER)

    # Tech stack summary
    parts.append(_build_tech_stack_section(entities))
    parts.append(SECTION_SEPARATOR)

    # Key decisions grouped by confidence
    high_conf = [d for d in decisions if d.get("confidence") == "high"]
    medium_conf = [d for d in decisions if d.get("confidence") == "medium"]

    if high_conf:
        parts.append("## Key Decisions (High Confidence)\n\n")
        parts.append("These are explicit, well-documented decisions. Follow them.\n\n")
        for d in high_conf:
            parts.append(_format_decision(d))

    if medium_conf:
        parts.append(SECTION_SEPARATOR)
        parts.append("## Additional Decisions (Medium Confidence)\n\n")
        parts.append("These are implied or partially documented. Use as guidance.\n\n")
        for d in medium_conf:
            parts.append(_format_decision(d))

    # Learnings section
    learnings_section = _build_learnings_section(repo)
    if learnings_section:
        parts.append(SECTION_SEPARATOR)
        parts.append(learnings_section)

    # Footer with stats
    parts.append(SECTION_SEPARATOR)
    footer_parts = [
        f"*Generated from {stats['total_sources']} sources "
        f"({stats.get('doc_sources', 0)} docs, {stats['adr_sources']} ADRs, "
        f"{stats['pr_sources']} PRs). "
        f"{stats['total_decisions']} decisions, {stats['unique_entities']} entities."
    ]
    if stats.get("total_learnings", 0) > 0:
        footer_parts.append(
            f" {stats['total_learnings']} learnings "
            f"({stats.get('bug_fixes', 0)} bug fixes, "
            f"{stats.get('gotchas', 0)} gotchas, "
            f"{stats.get('implementations', 0)} implementations)."
        )
    footer_parts.append("*\n")
    parts.append("".join(footer_parts))

    return "".join(parts)


def generate_context_file(repo: Repository, output_path: Path, format: str = "claude") -> Path:
    """Generate and write a context file."""
    content = generate_context(repo, format)
    output_path.write_text(content)
    return output_path


def _cursor_header() -> str:
    return """\
# Project Engineering Decisions

These are the architectural decisions and technology choices for this project,
extracted from documentation, PRs, and ADRs by setkontext.

When writing code, follow these decisions. If a user request would contradict
an established decision, flag the conflict before proceeding.

"""


def _build_tech_stack_section(entities: list[dict]) -> str:
    """Build a concise tech stack overview from entities."""
    tech = [e for e in entities if e.get("entity_type") == "technology"]
    patterns = [e for e in entities if e.get("entity_type") == "pattern"]

    parts = ["## Tech Stack & Patterns\n\n"]

    if tech:
        tech_names = [e["entity"] for e in tech[:15]]
        parts.append(f"**Technologies:** {', '.join(tech_names)}\n\n")

    if patterns:
        pattern_names = [e["entity"] for e in patterns[:10]]
        parts.append(f"**Patterns:** {', '.join(pattern_names)}\n\n")

    return "".join(parts)


def _build_learnings_section(repo: Repository) -> str:
    """Build a learnings section grouped by category."""
    bug_fixes = repo.get_recent_learnings(limit=10, category="bug_fix")
    gotchas = repo.get_recent_learnings(limit=10, category="gotcha")
    implementations = repo.get_recent_learnings(limit=10, category="implementation")

    if not bug_fixes and not gotchas and not implementations:
        return ""

    parts: list[str] = ["## Team Learnings\n\n"]
    parts.append("Knowledge captured from past coding sessions.\n\n")

    if bug_fixes:
        parts.append("### Known Bugs & Fixes\n\n")
        for l in bug_fixes:
            parts.append(_format_learning(l))

    if gotchas:
        parts.append("### Gotchas\n\n")
        for l in gotchas:
            parts.append(_format_learning(l))

    if implementations:
        parts.append("### Recent Implementations\n\n")
        for l in implementations:
            parts.append(_format_learning(l))

    return "".join(parts)


def _format_learning(l: dict) -> str:
    """Format a single learning for the context file."""
    parts: list[str] = []
    parts.append(f"- **{l.get('summary', 'Untitled')}**")

    if l.get("detail"):
        detail = l["detail"]
        if len(detail) > 200:
            detail = detail[:197] + "..."
        parts.append(f"\n  {detail}")

    if l.get("components"):
        comps = l["components"]
        if isinstance(comps, list) and comps:
            parts.append(f"\n  *Components:* {', '.join(comps)}")

    parts.append("\n\n")
    return "".join(parts)


def _format_decision(d: dict) -> str:
    """Format a single decision for the context file."""
    parts: list[str] = []
    parts.append(f"- **{d.get('summary', 'Untitled')}**")

    if d.get("reasoning"):
        # Keep reasoning concise â€” first 200 chars
        reasoning = d["reasoning"]
        if len(reasoning) > 200:
            reasoning = reasoning[:197] + "..."
        parts.append(f"\n  *Why:* {reasoning}")

    if d.get("alternatives"):
        alts = d["alternatives"]
        if isinstance(alts, list) and alts:
            parts.append(f"\n  *Rejected:* {', '.join(alts)}")

    if d.get("source_url"):
        parts.append(f"\n  *Source:* {d['source_url']}")

    parts.append("\n\n")
    return "".join(parts)
